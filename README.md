ФИО: Бедняков Дмитрий Викторович
Телефон: 89104824775
Телеграм: @FrostieRaelith
Mail: raelithdb@gmail.com
Вопросы: 
1.	Прям с задачами, не сталкивался, но я стараюсь инкорпорировать знания, полученные в области инфобеза в свой собственный код
2.	Ранее, не приходилось, но мы часто собираемся с единомыслящими одногруппниками и ревьювим на уязвимости/улучшение алгоритмизации свой собственный код, который мы и написали.
3.	Я искал уязвимости на платформах HTB и Portswigger academy в качестве обучения
4.	Я очень заинтересован в облачных технологиях. Для меня это хорошая возможность погрузиться в сферу облака и инфобеза одновременно.

# Часть 1. Security code review: GO


## Уязвимость №1

Уязвимость: SQL injection
```golang 
query := fmt.Sprintf("SELECT * FROM products WHERE name LIKE '%%%s%%'", searchQuery); rows, err := db.Query(query);
```
   

Последствия: получение доступа к информации, содержащейся в нашей базе данных, а так же потенциальная возможность провести инъекцию исполняемого кода под видом продукта.

**Исправление:** 
```golang
rows, err := db.Query("SELECT * FROM products WHERE name LIKE '%%%s%%', searchQuery) 
```
– использовать внутренний способ голанга парсить наш запрос в бд


## Уязвимость №2
  
Потенциальная XSS инъекция
```golang
var products []string
for rows.Next() {
    var name string
    err := rows.Scan(&name)
    if err != nil {
        log.Fatal(err)
    }
    products = append(products, name)
}
fmt.Fprintf(w, "Found products: %v\n", products);
```
Последствия: потенциальное исполнение произвольного кода в браузере клиента.

В данный момент времени, это не уязвимый код, но при не правильной передаче этих данных на страницу пользователю в таком виде в котором они находятся в данный момент, есть возможность использовать уязвимость описанную выше, вставить в нашу бд любой скрипт: “<script>alert(“hello”)</script> “ под видом имени продукта, и добиться его исполнения на стороне клиента.

**Исправление:** 

нужно проверять правильность данных которые мы получаем от нашей бд - если наши данные содержат спецсимволы, обрезать их.

## Уязвимость №3

Потенциальная уязвимость к DOS-атакам на базу данных

Так как в коде не настроены максимальное количество одновременных подключений (как это рекомендует документация SQL драйвера) к бд или таймаут не активных соединений, я могу предположить, что злоумышленник может сделать N-ое одновременное количество запросов в нашу базу данных ультимативно, заставляя ее либо задыхаться, либо вообще упасть.

Последствия: даунтайм нашего сервиса и повышенное время ожидания ответа сервера нашему клиенту.

**Исправление:** 
Мы можем либо выставить рекомендованные настройки SQL-драйвера, либо проверять IP нашего пользователя, и если от него идет огромное количество запросов, переставать обрабатывать запросы от данного IP. Последний наиболее рекомендованный способ, так как позволит нам справляться DOS атаками более эффективно.


# Часть 2: Security code review: Python


**Пример №2.1**

**XSS инъекция** 
```python
name = request.values.get('name');
age = request.values.get('age', 'unknown');
output = Template('Hello ' + name + '! Your age is ' + age + '.').render();
```
Последствия: потенциальное исполнение произвольного кода в браузере клиента. Далее – что угодно, переадресация на фишинговый сайт, ворующий данные, хищение куки, сессионных токенов, логинов с паролями и тд.

**Исправления:**

1) Нужно проверять данные на правильность ввода – проверяя правильность вводимых данных мы будем уверены что пользователь не сможет воспроизвести скрипт на нашем сайте.
2) Использовать встроенные типы рендера Flask – render_template() – самый надежный вариант. Flask безопасно обработает данные пользователя и нам не придется замедлять работу нашего приложение на проверку правильности
вводимых данных(нам все еще придется это делать для следующей уязвимости).




**SSTI инъекция**
```python
output = Template('Hello ' + name + '! Your age is ' + age + '.').render() – так если payload “{{7*7}}”, результатом будет 49
```
Последствия: экзекуция произвольного кода или команд на стороне сервера, что приведет к утечке данных и возможной потери контроля над сервером

**Исправление:**

Мы можем сделать проверку данных на правильность ввода и отсеивать/обрезать те запросы, которые потенциально опасны, либо мы можем использовать теймплэйт шаблоны без логики, но это будет требовать изменение структуры нашего приложения. 

**Вывод:** второй вариант сильно надежнее во избежание этой уязвимости, но требует больше усилий для реализации. Первый вариант будет требовать прописывания регулярных выражений проверяющий данные от пользователя на правильность, такое решение может привести к ошибкам, что даст злоумышленнику доступ к этой уязвимости.



**Пример №2.2**


**OS инъекция**
```python
cmd = 'nslookup ' + hostname;
output = subprocess.check_output(cmd, shell=True, text=True);
```
Последствия: полная потеря контроля над системой, эскалация в соседние системы приложения

**Исправление:** 
```python
output = subprocess.check_output(['nslookup ', hostname], text=True)
```
– так как subprocess обрабатывает запрос как единую команду, нам не нужно волноваться о потенциальной OS инъекции если мы будем использовать внутреннюю функцию subprocess’а, при этом не используя Shell.


# Часть 3. Моделирование угроз


1. Обработка запросов пользователя до подтверждения его авторизации может привести к тому, что пользователь будет иметь возможность обойти систему авторизации полностью. 
2. Если пользователь действительно сможет обойти сервис аутентификации, он сможет получить доступ к местам, не доступным для его уровня доступа, что приведет к вертикальной эскалации прав доступа и потери управления над приложением.
3. Я бы предложил поставить сервис аутентификации между пользователем и бэкэнд приложением. Это позволит нам точно знать, что запросы делает именно доверенный нами пользователь
4. Уточняющие вопросы:

1)Как обрабатывается запрос в базу данных?
   
2)Где хранятся реквизиты для входа пользователя?

3)Как обрабатываются запросы пользователя в данной системе и учитывают ли алгоритмы обработки запросов, кодировку текста со стороны пользователя?
