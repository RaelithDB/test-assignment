Вопросы: 
1.	Прям с задачами, не сталкивался, но я стараюсь инкорпорировать знания, полученные в области инфобеза в свой собственный код
2.	Ранее, не приходилось, но мы часто собираемся с единомыслящими одногруппниками и ревьювим на уязвимости/улучшение алгоритмизации свой собственный код, который мы и написали.
3.	Я искал уязвимости на платформах HTB и Portswigger academy в качестве обучения
4.	Я очень заинтересован в облачных технологиях. Для меня это хорошая возможность погрузиться в сферу облака и инфобеза одновременно.

# <strong>Часть 1. Security code review: GO</strong>


<strong>Уязвимость №1</strong>

Уязвимость: SQL injection
```golang 
query := fmt.Sprintf("SELECT * FROM products WHERE name LIKE '%%%s%%'", searchQuery); rows, err := db.Query(query);
```
   

Последствия: получение доступа к информации, содержащейся в нашей базе данных, а так же потенциальная возможность провести инъекцию исполняемого кода под видом продукта.

Исправление: 
```golang
rows, err := db.Query("SELECT * FROM products WHERE name LIKE '%%%s%%', searchQuery) 
```
– использовать внутренний способ голанга парсить наш запрос в бд


<strong>Уязвимость №2</strong>
  
Потенциальная XSS инъекция
```golang
var products []string
for rows.Next() {
    var name string
    err := rows.Scan(&name)
    if err != nil {
        log.Fatal(err)
    }
    products = append(products, name)
}
fmt.Fprintf(w, "Found products: %v\n", products);
```
Последствия: потенциальное исполнение произвольного кода в браузере клиента.

В данный момент времени, это не уязвимый код, но при не правильной передаче этих данных на страницу пользователю в таком виде в котором они находятся в данный момент, есть возможность использовать уязвимость описанную выше, вставить в нашу бд любой скрипт: “<script>alert(“hello”)</script> “ под видом имени продукта, и добиться его исполнения на стороне клиента.

Исправление: нужно проверять правильность данных которые мы получаем от нашей бд - если наши данные содержат спецсимволы, обрезать их.

<strong>Уязвимость №3</strong>

Потенциальная уязвимость к DOS-атакам на базу данных

Так как в коде не настроены максимальное количество одновременных подключений (как это рекомендует документация SQL драйвера) к бд или таймаут не активных соединений, я могу предположить, что злоумышленник может сделать N-ое одновременное количество запросов в нашу базу данных ультимативно, заставляя ее либо задыхаться, либо вообще упасть.

Последствия: даунтайм нашего сервиса и повышенное время ожидания ответа сервера нашему клиенту.

Исправление: Мы можем либо выставить рекомендованные настройки SQL-драйвера, либо проверять IP нашего пользователя, и если от него идет огромное количество запросов, переставать обрабатывать запросы от данного IP. Последний наиболее рекомендованный способ, так как позволит нам справляться DOS атаками более эффективно.


# <strong>Часть 2: Security code review: Python</strong>


<strong>Пример №2.1</strong>

XSS инъекция
```python
name = request.values.get('name');
age = request.values.get('age', 'unknown');
output = Template('Hello ' + name + '! Your age is ' + age + '.').render();
```
Последствия: потенциальное исполнение произвольного кода в браузере клиента. Далее – что угодно, переадресация на фишинговый сайт, ворующий данные, хищение куки, сессионных токенов, логинов с паролями и тд.

Исправления:

1) Нужно проверять данные на правильность ввода – проверяя правильность вводимых данных мы будем уверены что пользователь не сможет воспроизвести скрипт на нашем сайте.
2) Использовать встроенные типы рендера Flask – render_template() – самый надежный вариант. Flask безопасно обработает нашу переменную и нам не придется замедлять работу нашего приложение на проверку правильности
вводимых данных.


<strong>Пример №2.2</strong>


OS инъекция
```python
cmd = 'nslookup ' + hostname;
output = subprocess.check_output(cmd, shell=True, text=True);
```
Последствия: полная потеря контроля над системой, эскалация в соседние системы приложения

Исправление: 
```python
output = subprocess.check_output('nslookup ' + hostname, shell=True, text=True)
```
– так как subprocess обрабатывает запрос как единую команду, нам не нужно волноваться о потенциальной OS инъекции если мы будем использовать внутреннюю функцию subprocess’а


# <strong>Часть 3. Моделирование угроз</strong>


1. Обработка запросов пользователя до подтверждения его авторизации может привести к тому, что пользователь будет иметь возможность обойти систему авторизации полностью. 
2. Если пользователь действительно сможет обойти сервис аутентификации, он сможет получить доступ к местам, не доступным для его уровня доступа, что приведет к вертикальной эскалации прав доступа и потери управления над приложением.
3. Я бы предложил поставить сервис аутентификации между пользователем и бэкэнд приложением. Это позволит нам точно знать, что запросы делает именно доверенный нами пользователь
4. Как обрабатывается запрос в базу данных?
   
Где хранятся реквизиты для входа пользователя?

Как обрабатываются запросы пользователя в данной системе и учитывают ли алгоритмы обработки запросов, кодировку текста со стороны пользователя?
